# GORM 模型生成规范

> 本文档定义 GORM 模型的生成规则，供 LLM 在生成模型代码时参考。

---

## 命名规范

- **表名**：小写字母 + 下划线，禁止大写和数字
- **字段名（列名）**：小写字母 + 下划线
- **Go 字段名**：大驼峰（PascalCase）
- **关联字段**：列名 `${entity}_id`，Go 字段名 `${Entity}ID`，如 `org_id` / `OrgID`
- **层级自关联**：列名 `pid`，Go 字段名 `PID`

---

## 基本结构

所有模型必须遵循以下结构模板：

```go
package model

import "time"

// EntityName 实体注释（来自思维导图）
type EntityName struct {
	ID        string    `gorm:"primaryKey;column:id;type:bigint"`
	CreatedAt time.Time `gorm:"column:created_at;type:timestamptz;not null;index"`
	UpdatedAt time.Time `gorm:"column:updated_at;type:timestamptz;not null"`
	// 业务字段按思维导图中的顺序排列...
	FieldName string `gorm:"column:field_name;type:text;not null;comment:字段注释"` // 字段注释（来自思维导图）
}

func (EntityName) TableName() string {
	return "entity_name"
}
```

---

## 注释规范

- **表注释**：在 `type` 声明上方添加 Go 注释，内容来自思维导图中的表/实体描述
- **字段注释**：在字段行尾添加 Go 注释，内容来自思维导图中的字段描述
- 注释必须保留思维导图中的原始描述，不得省略或修改

### 数据库注释（COMMENT）

GORM 模型必须使用 `comment` 标签为表和字段添加数据库级别的注释，便于数据库管理工具查看字段含义。

#### 字段注释
- 在 gorm tag 中添加 `comment:xxx` 标签
- 注释内容与 Go 行尾注释保持一致
- 示例：`gorm:"column:email;type:text;not null;uniqueIndex;comment:邮箱地址"`

#### 表注释
- 通过实现 `TableName()` 方法无法直接设置表注释
- 需要在迁移时使用 `Migrator().SetComment()` 或在迁移 SQL 中添加 `COMMENT ON TABLE`
- 推荐在 Atlas 迁移文件中统一管理表注释：
  ```sql
  COMMENT ON TABLE "user" IS '系统用户';
  ```

---

## 字段定义规则

### 主键
- 必须使用 `ID string` 作为主键（使用 `string` 是因为 JavaScript 无法安全处理超过 `Number.MAX_SAFE_INTEGER` 的整数）
- Tag 格式：`gorm:"primaryKey;column:id;type:bigint"`
- 数据库存储为 `bigint`，Go 层使用 `string` 自动转换

### 时间字段
- 必须包含 `CreatedAt` 和 `UpdatedAt`
- 类型：`time.Time`
- 必须显式指定 `type:timestamptz`（GORM 默认使用 `timestamp without time zone`，不符合规范）
- `CreatedAt` 必须添加 `index` 索引，用于按创建时间排序查询
- Tag 格式：
  - `CreatedAt`：`gorm:"column:created_at;type:timestamptz;not null;index"`
  - `UpdatedAt`：`gorm:"column:updated_at;type:timestamptz;not null"`

### 关联字段（逻辑外键）
- 命名格式：`${Entity}ID`，如 `OrgID`、`UserID`
- 类型：`string`（与主键保持一致，避免前端精度丢失）
- 列名格式：`${entity}_id`，如 `org_id`、`user_id`
- Tag 格式：`gorm:"column:org_id;type:bigint;not null"`
- 层级自关联使用 `PID string` + `gorm:"column:pid;type:bigint"`

### 文本字段
- 类型：`string`
- 必须显式指定 `type:text`
- 示例：`gorm:"column:name;type:text;not null"`

### 布尔字段
- 启用/禁用统一使用 `Active bool`
- 必须指定默认值：`gorm:"column:active;not null;default:true"`

### 状态字段
- 业务流转状态使用 `State int16`
- 状态值从 1 开始，负值表示异常

### 排序字段
- 使用 `Sort int16`
- 默认值为 0：`gorm:"column:sort;not null;default:0"`

### JSONB 字段
- 对象类型：使用 `common.M`（`map[string]any`）
- 数组类型：使用 `common.A`（`[]any`），适用于数组或数组对象
- Tag 格式：`gorm:"column:xxx;type:jsonb;not null;default:'{}'"`（对象）或 `default:'[]'`（数组）
- 示例：
  ```go
  Metadata common.M `gorm:"column:metadata;type:jsonb;not null;default:'{}'"`
  Tags     common.A `gorm:"column:tags;type:jsonb;not null;default:'[]'"`
  ```

---

## Tag 格式规范

- Tag 顺序：`gorm:"primaryKey;column:xxx;type:xxx;not null;default:xxx;index/uniqueIndex;comment:xxx"`
- 所有字段必须显式指定 `column` 名称
- 核心字段必须包含 `not null`
- 有默认值的字段使用 `default:xxx`
- 所有业务字段必须包含 `comment:xxx` 标签（`id`、`created_at`、`updated_at` 等通用字段可省略）

---

## 索引规范

### 单字段索引
- 普通索引：`index`
- 唯一索引：`uniqueIndex`
- 示例：`gorm:"column:email;type:text;not null;uniqueIndex;comment:邮箱"`

### 联合索引

思维导图中可能使用以下格式标注联合索引：

```
索引: (field1, field2)
唯一索引: (field1, field2, field3)
```

#### 解析规则

1. **识别联合索引标注**：在思维导图的表定义中查找 `索引:` 或 `唯一索引:` 标注
2. **提取字段列表**：解析括号内的字段名，按顺序作为联合索引的列
3. **生成索引名称**：`idx_表名_字段1_字段2` 或 `idx_表名_字段1_字段2_unique`

#### GORM 联合索引语法

使用 `index` 或 `uniqueIndex` 标签，通过 `priority` 指定字段在索引中的顺序：

```go
// 联合索引: (org_id, name)
OrgID string `gorm:"column:org_id;type:bigint;not null;index:idx_role_org_name,priority:1;comment:组织ID"`
Name  string `gorm:"column:name;type:text;not null;index:idx_role_org_name,priority:2;comment:名称"`

// 联合唯一索引: (org_id, code)
OrgID string `gorm:"column:org_id;type:bigint;not null;uniqueIndex:idx_resource_org_code,priority:1;comment:组织ID"`
Code  string `gorm:"column:code;type:text;not null;uniqueIndex:idx_resource_org_code,priority:2;comment:编码"`
```

#### 完整示例

思维导图定义：
```
Resource 资源表
├── org_id: 组织ID
├── code: 编码
├── name: 名称
└── 唯一索引: (org_id, code)
```

生成的模型：
```go
// Resource 资源表
type Resource struct {
	ID        string    `gorm:"primaryKey;column:id;type:bigint"`
	CreatedAt time.Time `gorm:"column:created_at;type:timestamptz;not null;index"`
	UpdatedAt time.Time `gorm:"column:updated_at;type:timestamptz;not null"`
	OrgID     string    `gorm:"column:org_id;type:bigint;not null;uniqueIndex:idx_resource_org_code,priority:1;comment:组织ID"`
	Code      string    `gorm:"column:code;type:text;not null;uniqueIndex:idx_resource_org_code,priority:2;comment:编码"`
	Name      string    `gorm:"column:name;type:text;not null;comment:名称"`
}
```

#### 注意事项

- 联合索引名称必须在所有参与字段上保持一致
- `priority` 值决定字段在索引中的顺序，数值越小越靠前
- 单字段索引使用简写 `index` 或 `uniqueIndex`，联合索引必须指定索引名称
- 一个字段可以同时参与多个索引

---

## 字段排列顺序

1. **身份字段**：`ID`
2. **元数据字段**：`CreatedAt`、`UpdatedAt`
3. **业务字段**：按思维导图中定义的顺序排列（不做额外分组或重排）

---

## TableName 方法

- 必须实现 `TableName() string` 方法
- 返回小写下划线格式的表名
- 使用值接收者：`func (EntityName) TableName() string`

---

## 禁止事项

- 禁止使用 GORM 的外键关联（`foreignKey`、`references`）
- 禁止使用 `gorm.Model` 嵌入（字段命名不符合规范）
- 禁止使用 `serial` 或 `autoIncrement`
- 禁止使用 `varchar(n)` 或 `char(n)`
- 禁止省略 `column` 标签

---

## 模型示例

### 基础业务表
```go
// User 系统用户
type User struct {
	ID        string    `gorm:"primaryKey;column:id;type:bigint"`
	CreatedAt time.Time `gorm:"column:created_at;type:timestamptz;not null;index"`
	UpdatedAt time.Time `gorm:"column:updated_at;type:timestamptz;not null"`
	Email     string    `gorm:"column:email;type:text;not null;uniqueIndex;comment:邮箱地址"` // 邮箱地址
	Phone     string    `gorm:"column:phone;type:text;not null;index;comment:手机号码"`       // 手机号码
	Name      string    `gorm:"column:name;type:text;not null;comment:用户姓名"`              // 用户姓名
	Password  string    `gorm:"column:password;type:text;not null;comment:登录密码"`          // 登录密码
	Avatar    string    `gorm:"column:avatar;type:text;not null;comment:头像地址"`            // 头像地址
	Active    bool      `gorm:"column:active;not null;default:true;comment:是否启用"`         // 是否启用
}

func (User) TableName() string {
	return "user"
}
```

### 带关联的表
```go
// Role 角色
type Role struct {
	ID          string    `gorm:"primaryKey;column:id;type:bigint"`
	CreatedAt   time.Time `gorm:"column:created_at;type:timestamptz;not null;index"`
	UpdatedAt   time.Time `gorm:"column:updated_at;type:timestamptz;not null"`
	OrgID       string    `gorm:"column:org_id;type:bigint;not null;comment:所属组织"`        // 所属组织
	Name        string    `gorm:"column:name;type:text;not null;comment:角色名称"`            // 角色名称
	Description string    `gorm:"column:description;type:text;not null;comment:角色描述"`     // 角色描述
	Sort        int16     `gorm:"column:sort;not null;default:0;comment:排序权重"`            // 排序权重
	Active      bool      `gorm:"column:active;not null;default:true;comment:是否启用"`       // 是否启用
}

func (Role) TableName() string {
	return "role"
}
```

### 关联表（多对多中间表）
```go
// RolePermission 角色权限关联
type RolePermission struct {
	RoleID       string `gorm:"primaryKey;column:role_id;type:bigint;comment:角色ID"`       // 角色ID
	PermissionID string `gorm:"primaryKey;column:permission_id;type:bigint;comment:权限ID"` // 权限ID
}

func (RolePermission) TableName() string {
	return "role_permission"
}
```

---

## GORM 模型检查清单

生成 GORM 模型时，确认：

- [ ] 主键和关联字段使用 `string` 类型 + `type:bigint`（避免 JS 精度丢失）
- [ ] 包含 `CreatedAt` 和 `UpdatedAt` 时间字段（`type:timestamptz`，紧跟在 `ID` 之后）
- [ ] `CreatedAt` 字段包含 `index` 索引
- [ ] 业务字段按思维导图中的顺序排列
- [ ] 表注释和字段注释来自思维导图描述
- [ ] 业务字段包含 `comment:xxx` 标签（数据库级别注释）
- [ ] 文本字段使用 `string` + `type:text`
- [ ] 所有字段显式指定 `column` 名称
- [ ] 核心字段包含 `not null`
- [ ] 联合索引已正确解析（索引名称一致、priority 顺序正确）
- [ ] 实现 `TableName()` 方法返回小写下划线表名
- [ ] 无外键关联定义
- [ ] 无 `gorm.Model` 嵌入

---

# 命令自动化引导

> 本节定义项目中常用命令的执行规则和工作流程，供 LLM 在协助开发时参考。

---

## 环境准备

### 前置依赖

在执行任何命令前，确保以下工具已安装：

- **Go 1.24+**：项目运行时
- **Atlas CLI**：数据库迁移工具
  ```bash
  curl -sSf https://atlasgo.sh | sh
  ```
- **Python 3.10+**：迁移脚本运行时
- **Docker**：Atlas 开发数据库容器

### 配置文件

1. 复制 `.env.example` 为 `.env`
2. 填入实际的数据库连接信息
3. `.env` 文件不应提交到版本控制

---

## 数据库迁移工作流

### 核心命令

所有迁移命令通过 `scripts/migrate.py` 执行：

| 命令 | 用途 | 示例 |
|------|------|------|
| `diff` | 对比模型变更，生成迁移文件 | `scripts/migrate.py diff` |
| `apply` | 应用迁移到数据库 | `scripts/migrate.py apply` |
| `status` | 查看迁移状态 | `scripts/migrate.py status` |
| `inspect` | 查看数据库当前 schema | `scripts/migrate.py inspect` |
| `push` | 直接推送 schema（仅开发环境） | `scripts/migrate.py push` |
| `hash` | 重新生成迁移文件哈希 | `scripts/migrate.py hash` |

### 环境切换

默认使用 `local` 环境，生产环境需显式指定：

```bash
# 本地环境（默认）
scripts/migrate.py diff

# 生产环境
scripts/migrate.py --env prod apply
```

### 模型变更后的标准流程

当 GORM 模型发生变更时，按以下步骤操作：

```bash
# 1. 生成迁移文件
scripts/migrate.py diff

# 2. 检查生成的 SQL（在 migrations/ 目录，人工审核破坏性变更）
cat migrations/*.sql | tail -50

# 3. 应用迁移到本地数据库
scripts/migrate.py apply

# 4. 验证迁移状态
scripts/migrate.py status
```

---

## Atlas Loader 模型注册

当新增模型时，必须在 `cmd/atlas-loader/main.go` 中注册：

```go
models := []any{
    &model.User{},
    &model.Org{},
    // 新增模型在此处添加
    &model.NewEntity{},
}
```

**重要**：未注册的模型不会被 Atlas 识别，迁移时将被忽略。

---

## Go 项目常用命令

### 依赖管理

```bash
# 下载依赖
go mod download

# 整理依赖（移除未使用、添加缺失）
go mod tidy

# 更新特定依赖
go get -u github.com/example/package
```

### 代码生成

```bash
# Wire 依赖注入生成（如使用）
go generate ./...
```

### 运行与测试

```bash
# 运行应用
go run .

# 运行测试
go test ./...

# 带覆盖率的测试
go test -cover ./...
```

---

## 自动化任务清单

LLM 在执行特定任务时，应自动触发相关命令：

### 新增模型后

1. ✅ 在 `cmd/atlas-loader/main.go` 的 `models` 切片中注册模型
2. ✅ 在 `cmd/atlas-loader/main.go` 的 `tableComments` 中添加表注释
3. ✅ 执行 `scripts/migrate.py diff` 生成迁移
4. ✅ 人工审核生成的 SQL 文件
5. ✅ 执行 `scripts/migrate.py apply` 应用迁移

### 修改模型字段后

1. ✅ 执行 `scripts/migrate.py diff` 生成迁移
2. ✅ 人工审核生成的 SQL（特别关注破坏性变更）
3. ✅ 执行 `scripts/migrate.py apply` 应用迁移

### 添加新依赖后

1. ✅ 执行 `go mod tidy` 整理依赖

---

## 危险操作警告

以下操作需要用户明确确认：

- ⚠️ `--env prod` 任何生产环境操作
- ⚠️ 删除列或表的迁移（数据丢失风险）
- ⚠️ 修改列类型（可能导致数据转换失败）
- ⚠️ 删除索引（可能影响查询性能）

执行前必须：
1. 明确告知用户操作风险
2. 等待用户确认
3. 建议先在本地环境验证

---

## 常见问题处理

### 迁移冲突

如果迁移文件哈希不匹配：

```bash
# 重新计算哈希
scripts/migrate.py hash
```

### Atlas 命令未找到

```bash
# 安装 Atlas CLI
curl -sSf https://atlasgo.sh | sh
```

### 表注释维护

表注释通过 `cmd/atlas-loader/main.go` 中的 `tableComments` 映射管理：

```go
var tableComments = map[string]string{
    "user": "用户表",
    "org":  "组织表",
    // 新增表时在此添加注释
}
```

新增模型时，需同时在 `models` 切片和 `tableComments` 映射中添加对应条目。

---

# API 模块规范

> 本节定义 API 模块的结构规则，供 LLM 在生成 API 代码时参考。

---

## 目录结构

每个 API 模块位于 `api/` 目录下的独立子目录中，模块名称对应 API 路由路径：

```
api/
├── api.go              # 路由聚合与生命周期管理
├── index/              # 根路由模块
│   ├── common.go       # 模块通用定义（Provides、Controller、Service）
│   └── ping.go         # 具体的 API 处理方法
├── users/              # /users 路由模块
│   ├── common.go
│   └── ...
└── projects/           # /projects 路由模块
    ├── common.go
    └── ...
```

---

## common.go 模板

每个模块必须包含 `common.go` 文件，定义依赖注入和核心结构：

```go
package {module}

import (
	"server/common"

	"go.uber.org/fx"
)

var Provides = fx.Provide(
	func(i *Service) *Controller {
		return &Controller{{Module}X: i}
	},
	func(i common.Inject) *Service {
		return &Service{Inject: &i}
	},
)

type Controller struct {
	{Module}X *Service
}

type Service struct {
	*common.Inject
}
```

### 命名规则

| 元素 | 命名格式 | 示例 |
|------|----------|------|
| 包名 | 小写模块名 | `users`、`projects`、`index` |
| Controller 服务字段 | `{Module}X`（首字母大写） | `UsersX`、`ProjectsX`、`IndexX` |
| Service 注入字段 | `Inject` | 固定使用 `*common.Inject` |

### 示例

#### users 模块（对应 `/users` 路由）

```go
package users

import (
	"server/common"

	"go.uber.org/fx"
)

var Provides = fx.Provide(
	func(i *Service) *Controller {
		return &Controller{UsersX: i}
	},
	func(i common.Inject) *Service {
		return &Service{Inject: &i}
	},
)

type Controller struct {
	UsersX *Service
}

type Service struct {
	*common.Inject
}
```

#### projects 模块（对应 `/projects` 路由）

```go
package projects

import (
	"server/common"

	"go.uber.org/fx"
)

var Provides = fx.Provide(
	func(i *Service) *Controller {
		return &Controller{ProjectsX: i}
	},
	func(i common.Inject) *Service {
		return &Service{Inject: &i}
	},
)

type Controller struct {
	ProjectsX *Service
}

type Service struct {
	*common.Inject
}
```

---

## 路由与模块映射规则

**特殊模块：**
- `index` 模块可以定义自定义路径，不受模块名限制
  - 例如：`POST /login` => `index.Login`，`GET /user` => `index.GetUser`

**普通模块：**
- 模块名称必须与路由前缀一致
  - `users` 模块 => `/users/*`
  - `roles` 模块 => `/roles/*`
  - `projects` 模块 => `/projects/*`

---

## 标准路由约定

每个模块默认拥有 5 个标准 CRUD 路由，读取操作使用 `GET`，写入操作使用 `POST`：

| 路由 | Method | 方法 | 说明 |
|------|--------|------|------|
| `/{module}/:id` | GET | `FindById` | 根据 ID 获取单条记录 |
| `/{module}` | GET | `Find` | 获取列表（支持分页、筛选） |
| `/{module}/create` | POST | `Create` | 创建记录 |
| `/{module}/bulk_create` | POST | `BulkCreate` | 批量创建记录（可选） |
| `/{module}/update` | POST | `Update` | 更新记录 |
| `/{module}/delete` | POST | `Delete` | 删除记录 |

### 可选路由

模块可根据需要添加以下可选路由（使用 `_` 前缀标识）：

| 路由 | Method | 方法 | 说明 |
|------|--------|------|------|
| `/{module}/_search` | GET | `Search` | 异步搜索（用于下拉框、自动补全） |
| `/{module}/_exists` | GET | `Exists` | 异步验证（检查字段值是否存在） |

### 操作类路由

对模块记录进行特定操作的路由采用 `POST` 请求：

**命名规则：**
- 设置名词属性时使用 `set_` 前缀：`set_active`、`set_role`
- 本身就是动词时直接使用：`sort`、`save`、`export`、`check`

| 路由格式 | Method | 方法格式 | 说明 |
|----------|--------|----------|------|
| `/{module}/set_{noun}` | POST | `Set{Noun}` | 设置名词属性 |
| `/{module}/{verb}` | POST | `{Verb}` | 执行动词操作 |

示例：

| 路由 | Method | 方法 | 说明 |
|------|--------|------|------|
| `/{module}/set_active` | POST | `SetActive` | 设置启用/禁用状态 |
| `/{module}/set_role` | POST | `SetRole` | 设置角色 |
| `/{module}/sort` | POST | `Sort` | 排序 |
| `/{module}/save` | POST | `Save` | 保存 |
| `/{module}/export` | POST | `Export` | 导出 |
| `/{module}/check` | POST | `Check` | 检查 |

### 数据获取路由

特定数据的查询与返回（逻辑上只读，但需要传递复杂参数）使用 `fetch_` 前缀，采用 `POST` 请求：

| 路由格式 | Method | 方法格式 | 说明 |
|----------|--------|----------|------|
| `/{module}/fetch_{data}` | POST | `Fetch{Data}` | 获取特定数据 |

示例：

| 路由 | Method | 方法 | 说明 |
|------|--------|------|------|
| `/{module}/fetch_today_sales` | POST | `FetchTodaySales` | 获取今日销售数据 |
| `/{module}/fetch_infos` | POST | `FetchInfos` | 获取详细信息 |
| `/{module}/fetch_statistics` | POST | `FetchStatistics` | 获取统计数据 |

### 统计类路由

统计相关的接口使用 `_sum` 后缀表示合计，采用 `GET` 请求：

| 路由格式 | Method | 方法格式 | 说明 |
|----------|--------|----------|------|
| `/{module}/{scope}_stats/_sum` | GET | `{Scope}StatsSum` | 获取统计合计 |

示例：

| 路由 | Method | 方法 | 说明 |
|------|--------|------|------|
| `/{module}/today_stats/_sum` | GET | `TodayStatsSum` | 今日统计合计 |
| `/{module}/monthly_stats/_sum` | GET | `MonthlyStatsSum` | 月度统计合计 |
| `/{module}/sales_stats/_sum` | GET | `SalesStatsSum` | 销售统计合计 |

### 示例：users 模块路由

| 路由 | Method | 方法 |
|------|--------|------|
| `/users/:id` | GET | `users.FindById` |
| `/users` | GET | `users.Find` |
| `/users/create` | POST | `users.Create` |
| `/users/update` | POST | `users.Update` |
| `/users/delete` | POST | `users.Delete` |
| `/users/_search` | GET | `users.Search`（可选） |
| `/users/_exists` | GET | `users.Exists`（可选） |
| `/users/set_active` | POST | `users.SetActive`（可选） |
| `/users/set_role` | POST | `users.SetRole`（可选） |

---

## 注册模块到 api.go

新模块需要在 `api/api.go` 中注册，模块目录名对应路由前缀：

```go
package api

import (
	"context"
	"server/api/index"
	"server/api/users"     // 新增模块导入

	"github.com/cloudwego/hertz/pkg/app/server"
	"go.uber.org/fx"
)

var Options = fx.Options(
	index.Provides,
	users.Provides,  // 新增模块注册
	fx.Invoke(Routes),
)

func Routes(lc fx.Lifecycle, h *server.Hertz, index *index.Controller, users *users.Controller) {
	// index 模块 -> 根路由
	h.GET("", index.Ping)

	// users 模块 -> 标准 CRUD 路由
	h.GET("/users/:id", users.FindById)
	h.GET("/users", users.Find)
	h.POST("/users/create", users.Create)
	h.POST("/users/update", users.Update)
	h.POST("/users/delete", users.Delete)

	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			go h.Spin()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			if h != nil {
				return h.Shutdown(ctx)
			}
			return nil
		},
	})
}
```

---

## API 处理方法

每个请求在模块内是一个独立文件，包含 `Controller` 方法和 `Service` 方法。

### 文件结构

```
api/users/
├── common.go       # Provides、Controller、Service 定义
├── find.go         # Find 方法
├── find_by_id.go   # FindById 方法
├── create.go       # Create 方法
├── update.go       # Update 方法
└── delete.go       # Delete 方法
```

### 方法定义规范

每个文件包含两个方法：
- `Controller` 方法：处理 HTTP 请求，参数绑定，调用 Service
- `Service` 方法：业务逻辑实现，数据库操作，**必须包含 `user *common.IAMUser` 参数**

### common.IAMUser 结构

```go
type IAMUser struct {
	ID     string `json:"id"`      // 用户 ID
	OrgID  string `json:"org_id"`  // 组织 ID
	RoleID string `json:"role_id"` // 角色 ID
	Active bool   `json:"active"`  // 是否启用
	Ip     string `json:"-"`       // 客户端 IP
}
```

### 示例：delete.go

```go
package users

import (
	"context"

	"server/common"
	"server/model"

	"github.com/cloudwego/hertz/pkg/app"
)

// Controller 方法：处理 HTTP 请求
func (x *Controller) Delete(ctx context.Context, c *app.RequestContext) {
	var dto common.DeleteDto
	if err := c.BindAndValidate(&dto); err != nil {
		c.JSON(400, map[string]any{"error": err.Error()})
		return
	}
	user := c.MustGet("user").(*common.IAMUser)
	if err := x.UsersX.Delete(ctx, user, dto); err != nil {
		c.JSON(500, map[string]any{"error": err.Error()})
		return
	}
	c.JSON(200, map[string]any{"ok": true})
}

// Service 方法：业务逻辑（必须包含 user 参数）
func (x *Service) Delete(ctx context.Context, user *common.IAMUser, dto common.DeleteDto) (err error) {
	return x.Db.Where(`id in (?)`, dto.IDs).Delete(&model.User{}).Error
}
```

### 示例：find_by_id.go

```go
package users

import (
	"context"

	"server/common"
	"server/model"

	"github.com/cloudwego/hertz/pkg/app"
)

func (x *Controller) FindById(ctx context.Context, c *app.RequestContext) {
	var dto common.FindByIdDto
	if err := c.BindAndValidate(&dto); err != nil {
		c.JSON(400, map[string]any{"error": err.Error()})
		return
	}
	user := c.MustGet("user").(*common.IAMUser)
	data, err := x.UsersX.FindById(ctx, user, dto)
	if err != nil {
		c.JSON(500, map[string]any{"error": err.Error()})
		return
	}
	c.JSON(200, data)
}

func (x *Service) FindById(ctx context.Context, user *common.IAMUser, dto common.FindByIdDto) (data model.User, err error) {
	ctx = common.SetPipe(ctx, common.NewFindByIdPipe())
	err = dto.Take(ctx, x.Db.Model(&model.User{}), &data)
	return
}
```

### 示例：create.go

```go
package users

import (
	"context"

	"server/common"
	"server/model"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/kainonly/go/snowflake"
)

type CreateDto struct {
	Email    string `json:"email" vd:"required,email"`
	Name     string `json:"name" vd:"required"`
	Password string `json:"password" vd:"required,min=6"`
}

func (x *Controller) Create(ctx context.Context, c *app.RequestContext) {
	var dto CreateDto
	if err := c.BindAndValidate(&dto); err != nil {
		c.JSON(400, map[string]any{"error": err.Error()})
		return
	}
	user := c.MustGet("user").(*common.IAMUser)
	if err := x.UsersX.Create(ctx, user, dto); err != nil {
		c.JSON(500, map[string]any{"error": err.Error()})
		return
	}
	c.JSON(201, map[string]any{"ok": true})
}

func (x *Service) Create(ctx context.Context, user *common.IAMUser, dto CreateDto) (err error) {
	data := model.User{
		ID:       snowflake.GenerateString(),
		Email:    dto.Email,
		Name:     dto.Name,
		Password: dto.Password, // 实际应用需要加密
	}
	return x.Db.Create(&data).Error
}
```

### 通用 DTO 类型

`common` 包提供以下通用 DTO：

| DTO | 说明 |
|-----|------|
| `common.FindDto` | 列表查询（分页、排序、关键词） |
| `common.FindByIdDto` | 根据 ID 查询单条记录 |
| `common.SearchDto` | 异步搜索（下拉框、自动补全） |
| `common.ExistsDto` | 异步验证（检查字段值是否存在） |
| `common.DeleteDto` | 批量删除（`IDs []string`） |

### Service 可用依赖

在 Service 方法中直接访问注入的依赖：

- `x.Db` -> `*gorm.DB`
- `x.RDb` -> `*redis.Client`
- `x.V` -> `*Values`（配置）
- `x.Captcha` -> `*captcha.Captcha`
- `x.Locker` -> `*locker.Locker`

在 Controller 方法中通过 `x.{Module}X` 访问 Service：

- `x.UsersX.Delete(ctx, dto)`
- `x.UsersX.FindById(ctx, dto)`

---

## 新增模块检查清单

新增 API 模块时，确认：

- [ ] 在 `api/` 下创建模块目录（目录名即路由前缀，如 `api/users/` 对应 `/users`）
- [ ] 创建 `common.go`，包含 `Provides`、`Controller`、`Service`
- [ ] Controller 服务字段命名为 `{Module}X`（首字母大写，如 `UsersX`）
- [ ] Service 嵌入 `*common.Inject`
- [ ] 在 `api/api.go` 的 `Options` 中注册 `{module}.Provides`
- [ ] 在 `api/api.go` 的 `Routes` 函数参数中添加 `*{module}.Controller`
- [ ] 注册标准 CRUD 路由（GET: `/:id`, `/`；POST: `/create`, `/update`, `/delete`）

---

## common.Inject 可用依赖

`Service` 通过嵌入 `*common.Inject` 获得以下依赖：

| 字段 | 类型 | 说明 |
|------|------|------|
| `V` | `*Values` | 应用配置 |
| `Db` | `*gorm.DB` | 数据库连接 |
| `RDb` | `*redis.Client` | Redis 连接 |
| `Captcha` | `*captcha.Captcha` | 验证码服务 |
| `Locker` | `*locker.Locker` | 分布式锁服务 |

在 Controller 方法中通过 `x.{Module}X.{Field}` 访问，如 `x.UsersX.Db`。